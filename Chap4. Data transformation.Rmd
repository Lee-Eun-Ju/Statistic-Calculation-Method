---
title: "Chap4. Data transformation"
author: "LEE EUN JU"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### LIBRARY & DATA
nycflights13::flights (package::function -> 지정한 package내의 function 사용)
```{r data}
library(tidyverse)
library(nycflights13)
?flights
str(flights)
```
* dep_time, arr_time : 517 -> 5시 17분
* time_hour : dttime형("year-month-day dep_time") -> 연산 가능

### 1. Filter
```{r filter}
filter(flights, month==1, day==1) %>% head(10)
(dec25 = filter(flights, month==12, day==25))
```
%>% : 데이터를 저장하지 않고 볼 수 있다.(계속해서 저장하고 사용할 시, 메모리X)
()  : 새로운 변수로 지정하면서 동시에 출력할 수 있다.

### Filter - My turn
1) Find all flights that
```{r filter_myturn1}
#1-1. Had an arrival delay of two or more hours
filter(flights, arr_delay>=120) 

#1-2. Flew to Houston (IAH or HOU)
filter(flights, dest=="IAH"|dest=="HOU")
filter(flights, dest %in% c("IAH", "HOU"))

#1-3. Were operated by United (UA), American (AA), or Delta (DL). Find the data airline to get details.
filter(flights, carrier=="UA"|carrier=="AA"|carrier=="DL")

#1-4. Departed in summer (July, August, and September)
filter(flights, month==7|month==8|month==9)
filter(flights, between(month,7,9))

#1-5. Arrived more than two hours late, but didn’t leave late
filter(flights, arr_delay>=120 & dep_delay<=0)

#1-6. Were delayed by at least an hour, but made up over 30 minutes in flight
filter(flights, dep_delay>=60 & dep_delay-30>=arr_delay)
filter(flights, dep_delay>=60 & dep_delay-arr_delay>30)

#1-7. Departed between midnight and 6am (inclusive)
summary(flights$dep_time)
filter(flights, (dep_time>0 & dep_time<600)|dep_time==2400)
filter(flights, dep_time %% 2400 <=600) #2400으로 나누었을 때의 나머지
```

2) How many flights have a missing dep_time? What other variables are missing? What might these rows represent?
```{r}
sum(is.na(flights$dep_time))
filter(flights, is.na(dep_time)) %>% nrow()
filter(flights, is.na(dep_time)) #아예 출발 및 도착하지 않았다
```


### 2. Arrange
```{r}
arrange(flights, desc(dep_delay)) #desc : 내림차순
arrange(flights, dep_delay)
arrange(flights, year, month, desc(day)) #먼저 나온 순서대로 정렬
arrange(flights, year, month, day) %>% tail()

# missing은 내림차순이든 오름차순이든 무조건 맨밑에 정렬된다
df = tibble(x = c(5,2,NA))
arrange(df, x)
arrange(df, desc(x))
```

### Arrange - My turn
(1) How could you use arrange() to sort all missing values (in dep_time) to the start?
```{r}
arrange(flights, desc(is.na(dep_time)))
```
is.na(dep_time) : NA는 TRUE(1)로 인식하고, NA가 아닌 경우 FALSE(0)로 인식한다.  
이때, 내림차순 정렬을 하여 1(NA)부터 정렬한다.

(2) Sort flights to find the most delayed flights. Find the flights that left earliest.
```{r}
flights %>% arrange(desc(dep_delay))
flights %>% arrange(dep_delay)
```
내림차순 정렬(desc)을 통해 가장 지연된 비행기부터 정렬할 수 있다.  
오름차순 정렬에 따르면 가장 일찍 떠난 비행기는 97번이다.

(3) Sort flights to find the fastest (highest speed) flights.
```{r}
flights %>% arrange(air_time) %>% select(air_time, flight, everything())
```
4368, 4631 flight이 air_time이 20분으로 fatest flights이다.

(4) Which flights traveled the farthest? Which traveled the shortest?
```{r}
(fli_dist = flights %>% arrange(distance) %>% select(distance, flight, everything()))
fli_dist[1,] #shortest
fli_dist[dim(fli_dist)[1],] #farthest
```
shortest flight : 1632, farthest flight : 51


### 3. Select 
```{r}
select(flights, year, month, day)
select(flights, year:day)
select(flights, -(year:day))
```

* starts_with("abc") : abc로 시작하는 열이름 선택
* ends_with("xyz") : xyz로 끝나는 열이름 선택
* contains("ijk") : ijk가 포함되는 열이름 선택
* matches("(.)\\1") : 문자열(string)에서 정규표현식을 이용
* num_range("x", 1:3) : x1,x2,x3 

```{r}
select(flights, starts_with("arr"))
select(flights, ends_with("time"))
select(flights, contains("dep"))
rename(flights, YEAR=year)
select(flights, time_hour, air_time, everything()) #시험★
```

### Select - My turn
(1) Brainstorm as many ways as possible to select dep_time, dep_delay, arr_time, and arr_delay from flights
```{r}
flights %>% select(dep_time, dep_delay, arr_time, arr_delay)
flights %>% select(starts_with("dep"), starts_with("arr"))
flights %>% select(matches("dep_(.)"), matches("arr_(.)"))
```

(2) What happens if you include the name of a variable multiple times in a select() call?
```{r}
flights %>% select(dep_time, arr_time, dep_time)
```
반복하여 변수명을 포함할 시, 뒤의 변수는 무시한다.

(3) What does the one_of() function do? Why might it be helpful in conjunction with this vector?
```{r}
?select #all_of(), any_of()
vars <- c("year", "month", "day", "dep_delay", "arr_delay")
flights %>% select(one_of(vars))
```
all_of, any_of : Matches variable names in a character vector  
one_of : all_of, any_of의 상위버전

(4) Does the result of running the following code surprise you? How do the select helpers deal with case by default? How can you change that default?
```{r}
select(flights, contains("time"))
select(flights, contains("TIME"))
select(flights, contains("TIME", ignore.case=FALSE))
```
select()는 변수명의 대문자, 소문자 구분을 하지 않는다.  
이때, inore.case=FALSE 옵션을 추가하면 대소문자를 구분한다.

### 4. Mutate
```{r}
#mutate - 새로운 열을 덧붙임
flights_sml = select(flights, year:day, ends_with("delay"), distance, air_time)
mutate(flights_sml, gain=dep_delay-arr_delay, speed=distance/air_time*60)
mutate(flgiths_sml, gain=dep_delay-arr_delay, hours=air_time/60,
                    gain_per_hour=gain/hours)

#transmute - 생성한 열만으로 데이터 생성
transmute(flights, gain=dep_delay-arr_delay, hours=air_time/60,
                   gain_per_hour=gain/hours)
```

creation function
* %/% : 나눗셈의 몫(정수)
* %% : 나눗셈의 나머지
* logs : log(), log2(), log10()
* offsets : lag() - 이전 값, lead() - 다음 값 

* cumsum : 1, 1+2, 1+2+3 ....
* cummean : 데이터를 늘려가며 평균 값
* cummin : 데이터를 늘려가며 그 중 가장 작은 수
* cummax : 데이터를 늘려가며 그 중 가장 큰 수

* min_rank <- desc(): 가장 큰 수부터 순위를 매긴다.
* row_number
* dense_rank

### Mutate - My turn
1) Currently dep_time and sched_dep_time are convenient to look at, but hard to compute with because they’re not really continuous numbers. Convert them to a more convenient representation of number of minutes since midnight
```{r}
flights_my = mutate(flights, dep_min = ifelse(dep_time==2400, 0, (dep_time%/%100)*60 + dep_time%%100),
                             sched_dep_min = ifelse(sched_dep_time==2400, 0, 
                                                   (sched_dep_time%/%100)*60 + sched_dep_time%%100))
select(flights_my, dep_time, dep_min, sched_dep_time, sched_dep_min)

flights = mutate(flights, dep_time_cov = ((dep_time%/%100)*60 + dep_time%%100) %% 1440,
                 sched_dep_time_cov = ((shed_dep_time%/%100)*60 + sched_dep_time%%100) %% 1440)
```

2) Compare air_time with arr_time - dep_time. What do you expect to see? What do you see? What do you need to do to fix it?
```{r}
flights_my = mutate(flights, dep_min = ((dep_time%/%100)*60 + dep_time%%100) %% 1440,
                    arr_min = ((arr_time%/%100)*60 + arr_time%%100) %% 1440,
                    diff = arr_min - dep_min)

#air_tme과 diff의 차이? -> 변수가 하나일 때 histogram, boxplot 등을 통해 특징 확인
ggplot(flights_my) + geom_histogram((aes(air_time-diff)), binwidth=1)
```

3) Compare dep_time, sched_dep_time, and dep_delay. How would you expect those three numbers to be related?
```{r}
flights_my = mutate(flights, dep_min = ((dep_time%/%100)*60 + dep_time%%100) %% 1440,
                             sched_dep_min = ((sched_dep_time%/%100)*60 + sched_dep_time%%100) %% 1440,
                             delay_diff = dep_min - sched_dep_min )
ggplot(flights_my) +
  geom_histogram(aes(dep_delay-delay_diff))

fli = select(flights_my, dep_time, sched_dep_time, dep_min, sched_dep_min, dep_delay, delay_diff)
filter(fli, dep_delay-delay_diff !=0 )
```
=> delay되어 다음날 출발하게 된 경우 delay time이 맞지 않다.

4) Find the 10 most delayed flights using a ranking function. How do you want to handle ties? Carefully read the documentation for min_rank().
```{r}
flights = mutate(flights, flights_min = min_rank(desc(flights$dep_delay)),
                 flights_row = row_number(desc(flights$dep_delay)),
                 flights_dense = dense_rank(desc(flights$dep_delay)))
flights_rank = filter(flights,    
                      flights_min<=10|flights_row<=10|flights_dense<=10) %>%
               arrange(flights_min, flights_row, flights_dense) %>% 
               slice(1:10) #slice: 행선택
flights_rank
top_n(flights, 10, dep_delay) 

```  
* 주의해야할 점 
1:3 * 1:10 => 잘못된 계산(실제 계산된 값을 보고 틀렸는지 확인 필요함)

### 5. Summarise - Group by  
* na.rm=TRUE : 결측값을 통계량 계산할 때 포함하지 않는다.  
```{r}
# 전체 delay 평균
summarise(flights, delay = mean(dep_delay, na.rm=TRUE))

# day별 delay 평균
by_day = group_by(flights, year, month, day)
summarise(by_day, delay= mean(dep_delay, na.rm=TRUE))

flights_rank %>% group_by(year,month,day) %>% 
  summarise(mean=mean(dep_delay, na.rm=TRUE))
```

* Combining multiple operations with the pipe 
```{r}
# 목적지별 거리와 도착delay의 관계
by_dest = group_by(flights, dest)
delay = summarise(by_dest, 
                  count = n(),
                  dist = mean(distance, na.rm=TRUE),
                  delay = mean(arr_delay, na.rm=TRUE))
delay = filter(delay, count>20, dest!="HNL")
ggplot(data=delay, mapping=aes(x=dist, y=delay)) +
  geom_point(aes(size=count), alpha=1/3) + geom_smooth(se=FALSE) 

# Use %>% 
flights() %>% 
  group_by(dest) %>% 
  summarise(
    count=n(), 
    dist=mean(distance, na.rm=TRUE), 
    delay=mean(arr_delay, na.rm=TRUE)) %>% 
  filter(count>20, dest!="HNL") %>% 
  ggplot(mapping=aes(x=dist, y=delay)) +
  geom_point(aes(size=count), alpha=1/3) +
  geom_smooth(se=FALSE)
```

*Missing values
```{r}
#na.rm=TRUE를 이용하여 결측치 계산하지 않는다.
flights %>% 
  group_by(year,month,day) %>% 
  summarise(mean=mean(dep_delay, na.rm=TRUE))

#na데이터를 제거
not_cancelled = flights %>% 
  filter(!is.na(dep_delay), !is.na(arr_delay))
not_cancelled %>% 
  group_by(year,month,day) %>% 
  summarise(mean=mean(dep_delay))
```

*Counts - n() : group내 데이터 개수
        - sum(!is.na(x)) : NA가 아닌 데이터 개수
```{r}
#비행기 tailnum에 따른 delay 평균
delays = not_cancelled %>% 
  group_by(tailnum) %>% 
  summarise(delay=mean(arr_delay))
ggplot(data=delays, mapping=aes(x=delay)) +
  geom_freqpoly() #desnsity화

delays = not_cancelled %>% 
  group_by(tailnum) %>% 
  summarise(delay=mean(arr_delay, na.rm=TRUE),
            n=n())

ggplot(data=delays, mapping=aes(x=n, y=delay)) +
  geom_point(alpha=1/10)
delays %>% filter(n>25) %>% 
  ggplot(mapping = aes(x=n, y=delay)) +
  geom_point(alpha=1/10)
```

* Useful summary functions
```{r}
not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(
    avg_delay1 = mean(arr_delay),
    avg_delay2 = mean(arr_delay[arr_delay>0]),
    avg_delay3 = median(arr_delay)
  )

not_cancelled %>% 
  group_by(dest) %>% 
  summarise(distnace_sd = sd(distance)) %>% 
  arrange(desc(distance_sd))

not_cancelled %>%
  group_by(year, month, day) %>%
  summarise(
    first = min(dep_time),
    last = max(dep_time)
  )

not_cancelled %>%
  group_by(year, month, day) %>%
  summarise(
  first_dep = first(dep_time),
  last_dep = last(dep_time)
  )

not_cancelled %>%
  group_by(year, month, day) %>%
  mutate(r = min_rank(desc(dep_time)))-> A

not_cancelled %>%
  group_by(year, month, day) %>%
  mutate(r = min_rank(desc(dep_time))) %>%
  filter(r %in% range(r)) %>% head(10)

not_cancelled %>%
  group_by(dest) %>%
  summarise(carriers = n_distinct(carrier)) %>%
  arrange(desc(carriers))

not_cancelled %>%
  count(dest)
  not_cancelled %>%
  count(tailnum) # D942DN 4
  
not_cancelled %>%
  count(tailnum, wt = distance) # D942DN 3418
  filter(not_cancelled, tailnum=="D942DN") %>%
  summarise(sum_dist=sum(distance)) # 3418

# How many flights left before 5am?
# (these usually indicate delayed flights from the previous day)
not_cancelled %>%
  group_by(year, month, day) %>%
  summarise(n_early = sum(dep_time < 500))

# What proportion of flights are delayed by more than an hour?
not_cancelled %>%
  group_by(year, month, day) %>%
  summarise(hour_prop = mean(arr_delay > 60))

#logical value sum -> count
#logical value mean -> proportion 
```

* Grouping by multiple variables
여러 변수를 기준으로 그룹화하였을 때, summarise 반복시 한 수준의 그룹씩 벗겨진다.
```{r}
daily = group_by(flights, year, month, day)
(per_day = summarise(daily, flights=n())) 
(per_month = summarise(per_day, flights=sum(flights)))
(per_year = summarise(per_month, flights=sum(flights)))

#ungroup -> group화 모두 풀린다.
daily %>% 
  ungroup() %>% 
  summarise(flights=n())
```


### Summarise - My turn
1) Come up with another approach that will give you the same output as not_cancelled %>% count(dest) and not_cancelled %>% count(tailnum, wt = distance) (without using count()).
```{r}
not_cancelled = flights %>% filter(!is.na(dep_delay), !is.na(arr_delay))
not_cancelled %>% count(dest)
dest_by = group_by(not_cancelled, dest)
summarise(dest_by, n())

not_cancelled %>% count(tailnum, wt=distance)
tail_by = group_by(not_cancelled, tailnum)
summarise(tail_by, sum_dist=sum(distance))
```

2) Look at the number of canceled flights per day. Is there a pattern? Is the proportion of canceled flights related to the average delay?
```{r}
per_day = group_by(flights, year, month, day)
cancel = summarise(per_day, prop = mean(is.na(dep_delay)|is.na(arr_delay)))
cancel
```

3) Which carrier has the worst delays? Challenge: can you disentangle the effects of bad airports vs. bad carriers? Why/why not? (Hint: think about flights %>% group_by(carrier, dest) %>% summarise(n()))
```{r}
flights %>% group_by(carrier, dest ) %>% summarise(n())
```

4) Counts the number of flights to a destination and sorts them from highest to lowest.
```{r}

```

### Grouped mutates and filters
```{r}
#각 group에서 worst members
flights_sml %>% 
  group_by(year,month,day) %>% 
  filter(rank(desc(arr_delay)) < 10)

#dest별 delay 수
(popular_dests = flights %>% 
  group_by(dest) %>% 
  filter(n() > 365))

#dest별 delay 비중
popular_dests %>% 
  filter(arr_delay > 0) %>% 
  mutate(prop_delay=arr_delay/sum(arr_delay)) %>% 
  select(year:day, dest, arr_delay, prop_delay)
```

### Practice filters
```{r}
tibble(x=1:9, group=rep(c("a","b","c"), each=3)) %>% 
  mutate(x_mean = mean(x)) %>%  #group이 없었으므로 전체 평균
  group_by(group) %>% 
  mutate(x_mean_2 = mean(x)) #그룹별 평균

tibble(x=1:9, group=rep(c("a","b","c"), each=3)) %>% 
  mutate(y = x+2) %>% 
  group_by(group) %>% 
  mutate(z = x+2)

tibble(x = 1:9,
group = rep(c("a", "b", "c"), each = 3)) %>%
mutate(y = x %% 2) %>%
group_by(group) %>%
mutate(z = x %% 2)

tibble(x = 1:9,
group = rep(c("a", "b", "c"), each = 3)) %>%
mutate(y = log(x)) %>%
group_by(group) %>%
  mutate(z = log(x))
  
tibble(x = 1:9,
group = rep(c("a", "b", "c"), each = 3)) %>%
#group_by(group) %>%
mutate(lag_x = lag(x),
lead_x = lead(x))

tibble(x = 1:9,
group = rep(c("a", "b", "c"), each = 3)) %>%
mutate(x_cumsum = cumsum(x)) %>%
group_by(group) %>%
mutate(x_cumsum_2 = cumsum(x))

tibble(x = 1:9,
y = 9:1,
group = rep(c("a", "b", "c"), each = 3)) %>%
mutate(x_lte_y = x <= y) %>%
group_by(group) %>%
mutate(x_lte_y_2 = x <= y)

tibble(x = 1:9,
group = rep(c("a", "b", "c"), each = 3)) %>%
mutate(rnk = min_rank(x)) %>%
group_by(group) %>%
mutate(rnk2 = min_rank(x))

tibble(x = runif(9),
group = rep(c("a", "b", "c"), each = 3)) %>%
group_by(group) %>%
arrange(x)

tibble(group = rep(c("a", "b", "c"), each = 3),
x = runif(9)) %>%
group_by(group) %>%
arrange(x) %>%
mutate(lag_x = lag(x))

```

### Grouped mutates and filters - My turn
1) Which plane (tailnum) has the worst on-time record?
Consider two metrics:
1-1. proportion of flights not delayed or canceled, and
1-2. mean arrival delay.
```{r}

```

2) What time of day should you fly if you want to avoid delays as much as possible?
(Hint: The earlier the flight is scheduled, the lower its expected delay.)
```{r}

```

3-1) For each destination, compute the total minutes of delay.
3-2) For each flight, compute the proportion of the total delay for its
destination.
```{r}

```

4) Delays are typically temporally correlated: even once the problem that caused the initial delay has been resolved, later flights are delayed to allow earlier flights to leave.
Draw a the scatter plot between mean of dep_delay of flights and the dep_delay of the immediately preceding flight.
Hint 1: Using lag(), explore how the delay of a flight is related to the delay of the immediately preceding flight. Use lag() to get the info of dep_delay of a previous flight in the same origin. Before using lag(), the data should be ordered by origin, month, day, dep_time.
Hint 2: group by the dep_delay of the immediately preceding flight and find the mean of dep_delay of current flights.
```{r}

```

5) Look at each destination. Can you find flights that are suspiciously fast? (i.e. flights that represent a potential data entry error). Compute the air time of a flight relative to the shortest flight to that destination. Which flights were most delayed in the air?
Hint: Standardize air time.
```{r}

```

6) Find all destinations that are flown by at least two carriers. Use that information to rank the carriers.
```{r}

```


### 기타
* Comparisons operations
```{r}
sqrt(2)^2 ==2 #FALSE
near(sqrt(2)^2,2) #TRUE

(x = factor(c("a", "b", "c")))
x=="a" #TRUE 1개 존재 -> TRUE FALSE FALSE
sum(x!="a") #a가 아닌것 2개 존재 -> 2
```

* Logical operators( &:and, |:or )
```{r}
nov_dec = filter(flights, month %in% c(11,12)) # %in%:or
filter(flights, month==11|month==12) %>% head(5)

# !(x&y) : !x|!y , !(x|y) : !x&!y
filter(flights, !(arr_delay > 120 | dep_delay >120))
filter(flights, arr_delay <= 120, dep_delay <= 120)
```

* Missing values
- missing vlaues 포함한 연산 처리시, 모두 NA 처리가 된다.
```{r}
NA > 5
10 == NA
NA +10

x= c(1,2,NA)
is.na(x)
sum(is.na(x))

#condition이 true일때만 na를 보여줌
df= tibble(x=c(1,NA,3)) 
filter(df, x>1)
filter(df, is.na(x)|x>1)
```

